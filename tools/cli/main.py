#!/usr/bin/env python3
import argparse
import json
import os
from io import TextIOWrapper
from collections import namedtuple

import freetype
import PIL
from PIL import Image, ImageDraw

CGlyph = namedtuple(
    "CGlyph",
    [
        "unicode",
        "width",
        "height",
        "advance_x",
        "offset_x",
        "offset_y",
        "bitmap",
    ])


def pack_bitmap(buffer, width, height, pitch):
    packed = []
    current_bit = 0
    current_byte = 0
    for y in range(height):
        for x in range(width):
            byte_index = y * pitch + (x // 8)
            bit_mask = 0x80 >> (x % 8)
            pixel_on = (buffer[byte_index] & bit_mask) != 0
            if pixel_on:
                current_byte |= 0x80 >> current_bit
            current_bit += 1
            if current_bit == 8:
                current_bit = 0
                packed.append(current_byte)
                current_byte = 0
    if current_bit != 0:
        packed.append(current_byte)

    return packed


def debug_packed(buffer, width, height):
    line = ""
    col = 0
    for bit in range(width * height):
        byte_index = bit // 8
        bit_index = bit % 8
        pixel_on = (buffer[byte_index] & (0x80 >> bit_index)) != 0
        line += "#" if pixel_on else "."
        col += 1
        if col == width:
            print(line)
            line = ""
            col = 0


def debug_image(cglyph: CGlyph):
    image = Image.new('RGB', (cglyph.width, cglyph.height), color='white')
    draw = ImageDraw.Draw(image)
    for bit in range(cglyph.width * cglyph.height):
        byte_index = bit // 8
        bit_index = bit % 8
        pixel_on = (cglyph.bitmap[byte_index] & (0x80 >> bit_index)) != 0
        x = bit % cglyph.width
        y = bit / cglyph.width
        draw.point((x, y), (255, 255, 255) if pixel_on else (0, 0, 0))
    image.show()


def build_glyph(face, char) -> CGlyph:
    face.load_char(char, freetype.FT_LOAD_RENDER | freetype.FT_LOAD_TARGET_MONO)

    bitmap = face.glyph.bitmap
    width = bitmap.width
    rows = bitmap.rows
    pitch = bitmap.pitch
    buffer = bitmap.buffer

    packed = pack_bitmap(buffer, width, rows, pitch)

    cglyph = CGlyph(
        unicode=ord(char),
        width=width,
        height=rows,
        advance_x=face.glyph.advance.x >> 6,
        offset_x=face.glyph.bitmap_left,
        offset_y=face.glyph.bitmap_top,
        bitmap=packed
    )

    return cglyph


def render_c(out: TextIOWrapper, name: str, cglyph: CGlyph, bytes_per_line=16):
    out.write(f"const uint8_t {name}[] PROGMEM = {{\n")
    for offset in range(0, len(cglyph.bitmap), bytes_per_line):
        chunk = cglyph.bitmap[offset:offset + bytes_per_line]
        hex_part = ', '.join(f'0x{b:02X}' for b in chunk) + ",\n"
        out.write("\t" + hex_part)
    out.write("};\n")


# Example usage
def normalize(candidate):
    if isinstance(candidate, int):
        return candidate

    if not isinstance(candidate, str):
        raise TypeError("Input must be a string.")

    hex_str = candidate.strip().lower()

    if not hex_str.startswith("0x"):
        raise ValueError("String must start with '0x' or '0X'.")

    try:
        return int(hex_str, 16)
    except ValueError:
        raise ValueError(f"Invalid hexadecimal number: {hex_str}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="""
    Tool inspired by Adafruit-GFX-Library/fontconvert.
    Prepare compressed glyphs from different fonts based on config.json file.
    """)
    parser.add_argument("config", type=argparse.FileType("r"))
    parser.add_argument("--fonts", "-f", default="../../resources/fonts/")
    parser.add_argument("--output", "-o", default="../../platformio/src/autogenerated/fonts")
    parser.add_argument("--preview-image", "-pi", action="store_true", default=False)
    parser.add_argument("--preview-console", "-pc", action="store_true", default=False)

    args = parser.parse_args()

    config = json.load(args.config)

    os.makedirs(args.output, exist_ok=True)

    for key in config.keys():
        settings = config[key]
        glyphs: list[CGlyph] = []
        size = settings["size"]
        font = settings["font"]
        sets = settings["sets"]
        f_name = os.path.join(args.output, f"{key}_{size}.h")
        font_path = os.path.join(args.fonts, font)
        with open(f_name, "w") as out:
            out.write(f"#ifndef _font_{key}_{size}_h_\n")
            out.write(f"#define _font_{key}_{size}_h_\n\n")
            out.write(f"#include <stdint.h>\n\n")

            out.write("#include \"Font.h\"\n")

            out.write(f"#ifndef PROGMEN\n")
            out.write(f"#define PROGMEM\n")
            out.write(f"#endif\n\n")

            face = freetype.Face(font_path)
            face.set_pixel_sizes(0, size)

            for s in sets:
                set_type = s["type"]
                if set_type == "range":
                    characters = range(normalize(s["start"]), normalize(s["end"]) + 1)
                elif set_type == "set":
                    characters = s["set"]
                else:
                    continue

                for c in characters:
                    c = normalize(c)
                    glyph_name = f"glyph_{key}_{size}_{c}"
                    glyph = build_glyph(face, chr(c))
                    render_c(out, glyph_name, glyph)
                    glyphs.append(glyph)

                    if args.preview_image:
                        debug_image(glyph)
                    if args.preview_console:
                        debug_packed(glyph.bitmap, glyph.width, glyph.height)

            out.write(f"const glyph_t glyphs_{key}_{size}[] PROGMEM = {{\n")
            out.write(f"\t{{ 0x{len(glyphs):04X}, {0}, {face.size.height >> 6}, {0}, {0}, {0}, 0x00 }},\n")
            for glyph in glyphs:
                ptr = f"glyph_{key}_{size}_{glyph.unicode}"
                out.write(
                    f"\t{{ 0x{glyph.unicode:04X}, {glyph.width}, {glyph.height}, {glyph.advance_x}, {glyph.offset_x}, {glyph.offset_y}, (uint8_t *){ptr} }},\n")

            out.write("};\n")

            out.write(f"\n#endif // _font_{key}_{size}_h_\n")
